C51 COMPILER V9.60.0.0   Z_MAIN                                                            07/09/2022 18:24:17 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE Z_MAIN
OBJECT MODULE PLACED IN .\obj\z_main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\z_main.c LARGE OPTIMIZE(8,SPEED) BROWSE ORDER INCDIR(.\src) DEBUG OB
                    -JECTEXTEND PRINT(.\lst\z_main.lst) TABS(2) OBJECT(.\obj\z_main.obj)

line level    source

   1          /*
   2            1、串口1调试   ok
   3            2、串口2调试   ok
   4            3、定时器0调试    ok
   5            4、定时器1调试    ok
   6            5、PS2手柄调试   ok
   7            6、4通道PWM调试    ok
   8            7、舵机调试      ok
   9            8、W25Q64存储调试  ok
  10            
  11            调试的过程：
  12            如上，一个一个模块调通，最后组合
  13            左边的目录结构就是对应每一个模块调试好做成一个模块文件，便于移植
  14            
  15            看程序方法：
  16            看程序的时候，从main文件的main函数看起
  17            基本的程序思路是
  18            主函数->各个模块初始化->大循环while(1) 
  19                        ->中断(串口、定时器等)
  20            大家在深究本程序时，建议大家先去了解各个模块的原理，然后看懂文件结构和
             -程序结构，最后再细究算法问题
  21            
  22            智能传感器版本增加内容：
  23            
  24            IO口分布
  25            循迹 S1 P27 P10
  26            
  27            超声波 S3 P45 P11
  28            
  29            声音 S4 P42
  30            
  31            颜色 S6 P17 P15
  32            
  33            手动遥控功能
  34            1、手柄遥控
  35            2、APP遥控
  36            3、WIFI遥控
  37            
  38            图形化编程功能
  39            
  40            功能切换：绿灯模式下通过左边上下左右键切换功能，通过蜂鸣器的声音的响声
             -播报功能
  41            
  42            波特率 22.1184 
  43          */
  44          
  45          #include <stdio.h>
  46          #include <string.h>
  47          #include <intrins.h>
  48          #include "z_stc15.h"
  49          #include "z_main.h"
  50          #include "z_uart.h"
  51          #include "z_delay.h"
  52          #include "z_gpio.h"
C51 COMPILER V9.60.0.0   Z_MAIN                                                            07/09/2022 18:24:17 PAGE 2   

  53          #include "z_ps2.h"
  54          #include "z_timer.h"
  55          #include "z_w25q64.h"
  56          #include "z_global.h"
  57          #include "z_adc.h"
  58          #include "z_sensor.h"
  59          #include "z_kinematics.h" //逆运动学算法
  60          
  61          
  62          u8 i;
  63          u16 do_start_index, do_time, group_num_start, group_num_end, group_num_times;
  64          u32 bias_systick_ms_bak = 0;
  65          u8 needSaveFlag = 0;
  66          u32 save_addr_sector = 0, save_action_index_bak = 0;
  67          u8 psx_buf[9]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};   
  68          u32 downLoadTime = 0;
  69          u32 action_time = 0;
  70          
  71          code const char *pre_cmd_set_red[PSX_BUTTON_NUM] = {
  72            "<PS2_RED01:#005P0600T2000!^#005PDST!>",  //L2              
  73            "<PS2_RED02:#005P2400T2000!^#005PDST!>",  //R2              
  74            "<PS2_RED03:#004P0600T2000!^#004PDST!>",  //L1              
  75            "<PS2_RED04:#004P2400T2000!^#004PDST!>",  //R1      
  76            "<PS2_RED05:#002P2400T2000!^#002PDST!>",  //RU              
  77            "<PS2_RED06:#003P2400T2000!^#003PDST!>",  //RR              
  78            "<PS2_RED07:#002P0600T2000!^#002PDST!>",  //RD              
  79            "<PS2_RED08:#003P0600T2000!^#003PDST!>",  //RL        
  80            "<PS2_RED09:$DJR!>",              //SE              
  81            "<PS2_RED10:>",                     //AL               
  82            "<PS2_RED11:>",                     //AR              
  83            "<PS2_RED12:$DJR!>",              //ST    
  84            "<PS2_RED13:#001P0600T2000!^#001PDST!>",  //LU              
  85            "<PS2_RED14:#000P0600T2000!^#000PDST!>",  //LR                  
  86            "<PS2_RED15:#001P2400T2000!^#001PDST!>",  //LD              
  87            "<PS2_RED16:#000P2400T2000!^#000PDST!>",  //LL  
  88          };
  89          
  90          code const char *pre_cmd_set_grn[PSX_BUTTON_NUM] = {
  91            "<PS2_GRN01:#005P0600T2000!^#005PDST!>",  //L2              
  92            "<PS2_GRN02:#005P2400T2000!^#005PDST!>",  //R2              
  93            "<PS2_GRN03:#004P0600T2000!^#004PDST!>",  //L1              
  94            "<PS2_GRN04:#004P2400T2000!^#004PDST!>",  //R1      
  95            "<PS2_GRN05:#002P2400T2000!^#002PDST!>",  //RU              
  96            "<PS2_GRN06:#003P2400T2000!^#003PDST!>",  //RR              
  97            "<PS2_GRN07:#002P0600T2000!^#002PDST!>",  //RD              
  98            "<PS2_GRN08:#003P0600T2000!^#003PDST!>",  //RL        
  99            "<PS2_GRN09:$DJR!>",              //SE              
 100            "<PS2_GRN10:>",                     //AL               
 101            "<PS2_GRN11:>",                     //AR              
 102            "<PS2_GRN12:$DJR!>",              //ST    
 103            "<PS2_GRN13:#001P0600T2000!^#001PDST!>",  //LU              
 104            "<PS2_GRN14:#000P0600T2000!^#000PDST!>",  //LR                  
 105            "<PS2_GRN15:#001P2400T2000!^#001PDST!>",  //LD              
 106            "<PS2_GRN16:#000P2400T2000!^#000PDST!>",  //LL                
 107          };
 108          
 109          /*
 110            代码从main里开始执行
 111            在进入大循环while(1)之前都为各个模块的初始化
 112            最后在大循环处理持续执行的事情
 113            另外注意uart中的串口中断，接收数据处理
 114            timer中的定时器中断，舵机的脉冲收发就在那里
C51 COMPILER V9.60.0.0   Z_MAIN                                                            07/09/2022 18:24:17 PAGE 3   

 115          */
 116          
 117          kinematics_t kinematics;
 118          int ret;
 119          
 120          void main(void) {
 121   1        setup_global();     //初始化全局变量
 122   1        setup_gpio();     //初始化IO口
 123   1        setup_djio();     //初始化舵机IO口
 124   1        setup_nled();     //初始化工作指示灯
 125   1        setup_beep();     //初始化定时器  
 126   1        
 127   1        setup_w25q64();     //初始化存储器W25Q64
 128   1        setup_ps2();      //初始化PS2手柄
 129   1        setup_uart1();      //初始化串口1
 130   1        setup_uart2();      //初始化串口2
 131   1        
 132   1        setup_systick();    //初始化滴答时钟，1S增加一次systick_ms的值
 133   1        
 134   1        setup_servo_bias();   //初始化偏差
 135   1        setup_dj_timer();   //初始化定时器0 处理舵机PWM输出
 136   1        setup_interrupt();    //初始化总中断
 137   1      
 138   1        setup_sensor();     //初始化传感器IO口
 139   1        
 140   1        setup_start();      //初始化启动信号
 141   1        
 142   1        //kinematics 90mm 105mm 98mm 150mm
 143   1        setup_kinematics(90, 105, 98, 150, &kinematics);
 144   1        
 145   1          while(1) {
 146   2          loop_nled();              //循环执行工作指示灯，500ms跳动一次.
 147   2          loop_uart();              //串口数据接收处理
 148   2          if(millis() - downLoadTime > 1000) {  //保证下载的时候不受其他功能的干扰
 149   3            loop_action();            //动作组批量执行
 150   3            loop_bt_once();           //蓝牙修改波特率和名称
 151   3            loop_ps2_data();          //循环读取PS2手柄数据
 152   3            loop_ps2_button();        //处理手柄上的按钮
 153   3            loop_monitor();           //定时保存一些变量
 154   3      //      AI_jiaqu();               //传感器处理
 155   3          } 
 156   2        }
 157   1      }
 158          
 159          //--------------------------------------------------------------------------------
 160          /*
 161            初始化函数实现
 162          */
 163          //初始化全局变量
 164          void setup_global(void) {
 165   1        //全局变量初始化
 166   1        global_init();
 167   1      }
 168          //初始化IO口
 169          void setup_gpio(void) {
 170   1        //IO初始化
 171   1        io_init();
 172   1      }
 173          //初始化工作指示灯 初始化已在io_init中初始化
 174          void setup_nled(void) {
 175   1        nled_off();     //工作指示灯关闭
 176   1      }
C51 COMPILER V9.60.0.0   Z_MAIN                                                            07/09/2022 18:24:17 PAGE 4   

 177          //初始化蜂鸣器 初始化已在io_init中初始化
 178          void setup_beep(void) {
 179   1        beep_off();     //关闭蜂鸣器
 180   1      }     
 181          //初始化舵机IO口
 182          void setup_djio(void) {
 183   1        dj_io_init();   //舵机IO口初始化
 184   1      } 
 185          
 186          //初始化存储器W25Q64
 187          void setup_w25q64(void) {
 188   1        //存储器初始化，读取ID进行校验，若错误则长鸣不往下执行
 189   1        w25x_init();
 190   1        while(w25x_readId()!= W25Q64)beep_on();
 191   1        
 192   1        w25x_read((u8 *)(&eeprom_info), W25Q64_INFO_ADDR_SAVE_STR, sizeof(eeprom_info_t));  //读取全局变量
 193   1        if(eeprom_info.version != VERSION) {  //判断版本是否是当前版本
 194   2          eeprom_info.version = VERSION;    //复制当前版本
 195   2          eeprom_info.dj_record_num = 0;    //学习动作组变量赋值0
 196   2        } 
 197   1        
 198   1        if(eeprom_info.dj_bias_pwm[DJ_NUM] != FLAG_VERIFY) {
 199   2          for(i=0;i<DJ_NUM;i++) {
 200   3            eeprom_info.dj_bias_pwm[i] = 0;
 201   3          }
 202   2          eeprom_info.dj_bias_pwm[DJ_NUM] = FLAG_VERIFY;
 203   2        }
 204   1        
 205   1        if(eeprom_info.digtal_mode > 1) {
 206   2          eeprom_info.digtal_mode = 0;
 207   2        }
 208   1      } 
 209          
 210          //初始化PS2手柄
 211          void setup_ps2(void) {
 212   1        //手柄初始化
 213   1        psx_init();
 214   1      }
 215          //初始化定时器2 处理舵机PWM输出
 216          void setup_dj_timer(void) {
 217   1        timer0_init();  //舵机 定时器初始化
 218   1      }
 219          
 220          //初始化串口1
 221          void setup_uart1(void) {
 222   1        //串口1初始化
 223   1        uart1_init(115200);
 224   1        //uart1_close();
 225   1        uart1_open();
 226   1        //串口发送测试字符
 227   1        uart1_send_str((u8 *)"uart1 check ok!");
 228   1      }
 229          //初始化串口2
 230          void setup_uart2(void) {
 231   1        //串口2初始化
 232   1        uart2_init(115200);
 233   1        //uart2_close();
 234   1        uart2_open();
 235   1        //串口发送测试字符
 236   1        uart2_send_str((u8 *)"uart2 check ok!");
 237   1      } 
 238          //初始化串口4
C51 COMPILER V9.60.0.0   Z_MAIN                                                            07/09/2022 18:24:17 PAGE 5   

 239          void setup_uart4(void) {
 240   1        //串口4初始化
 241   1        uart4_init(115200);
 242   1        //uart4_close();
 243   1        uart4_open();
 244   1        
 245   1        //串口发送测试字符
 246   1        uart4_send_str((u8 *)"uart4 check ok!");
 247   1      } 
 248          //初始化滴答时钟，1S增加一次systick_ms的值
 249          void setup_systick(void) {
 250   1        //系统滴答时钟初始化 
 251   1        timer3_init();
 252   1      }
 253          
 254          
 255          //初始化启动信号
 256          void setup_start(void) {
 257   1        
 258   1        //蜂鸣器LED 名叫闪烁 示意系统启动
 259   1        beep_on();nled_on();mdelay(200);beep_off();nled_off();mdelay(200);
 260   1        beep_on();nled_on();mdelay(200);beep_off();nled_off();mdelay(200);
 261   1        beep_on();nled_on();mdelay(200);beep_off();nled_off();mdelay(200);
 262   1        
 263   1        //执行预存命令 {G0000#000P1500T1000!#000P1500T1000!}
 264   1        if(eeprom_info.pre_cmd[PRE_CMD_SIZE] == FLAG_VERIFY) {
 265   2          strcpy((char *)uart_receive_buf, (char *)eeprom_info.pre_cmd);
 266   2          if(eeprom_info.pre_cmd[0] == '$') {
 267   3            parse_cmd(eeprom_info.pre_cmd);
 268   3          } else {
 269   3            for(i=16;i<strlen((char *)uart_receive_buf);i+=15) {
 270   4              uart_receive_buf[i] = '0';
 271   4              uart_receive_buf[i+1] = '0';
 272   4              uart_receive_buf[i+2] = '0';
 273   4              uart_receive_buf[i+3] = '0';
 274   4            }
 275   3            parse_action(uart_receive_buf);
 276   3          }
 277   2        }
 278   1        
 279   1        
 280   1      } 
 281          //初始化其他
 282          void setup_servo_bias(void) { 
 283   1        
 284   1        //将偏差带入初始值
 285   1        for(i=0;i<DJ_NUM;i++) {
 286   2          duoji_doing[i].aim = 1500+eeprom_info.dj_bias_pwm[i];
 287   2          duoji_doing[i].cur = duoji_doing[i].aim;
 288   2          duoji_doing[i].inc = 0;   
 289   2        }
 290   1      }
 291          
 292          //初始化总中断
 293          void setup_interrupt(void) {
 294   1        //串口1设为高优先级
 295   1        IP = 0X10;
 296   1        //IP2 = 0X01;
 297   1        //总中断打开
 298   1        EA = 1;
 299   1      } 
 300          //--------------------------------------------------------------------------------
C51 COMPILER V9.60.0.0   Z_MAIN                                                            07/09/2022 18:24:17 PAGE 6   

 301          
 302          
 303          //--------------------------------------------------------------------------------
 304          /*
 305            主循环函数实现
 306          */
 307          //循环执行工作指示灯，500ms跳动一次
 308          void loop_nled(void) {
 309   1        static u32 systick_ms_bak = 0;
 310   1        if(millis() - systick_ms_bak >= 500) {
 311   2          systick_ms_bak = millis();
 312   2          nled_switch();  
 313   2        }
 314   1      }   
 315          //串口数据接收处理
 316          void loop_uart(void) {
 317   1        if(uart1_get_ok) {
 318   2          //测试发回去
 319   2          //uart1_send_str(uart_receive_buf);
 320   2      
 321   2          if(uart1_mode == 1) {       //命令模式
 322   3            //uart1_send_str(">cmd");
 323   3            parse_cmd(uart_receive_buf);      
 324   3          } else if(uart1_mode == 2 || uart1_mode == 3) {   //单个舵机模式 多个舵机模式
 325   3            //uart1_send_str(">sig");
 326   3            parse_action(uart_receive_buf);
 327   3          } else if(uart1_mode == 4) {    //保存模式
 328   3            //uart1_send_str(">save");
 329   3            //uart1_send_str(uart_receive_buf);
 330   3            action_save(uart_receive_buf);
 331   3            downLoadTime = millis();
 332   3          } 
 333   2          
 334   2          memset(uart_receive_buf, 0, sizeof(uart_receive_buf));
 335   2          uart1_mode = 0;
 336   2          uart1_get_ok = 0;
 337   2        }
 338   1        
 339   1        return;
 340   1      } 
 341          
 342          //定时保存一些变量
 343          void loop_monitor(void) {
 344   1        static u32 saveTime = 3000;
 345   1        if((needSaveFlag == 1) || (millis() - bias_systick_ms_bak > saveTime)) {
 346   2          needSaveFlag = 0;
 347   2          bias_systick_ms_bak = millis();
 348   2          rewrite_eeprom();
 349   2        } 
 350   1        return;
 351   1      } 
 352          
 353          
 354          void loop_ps2_data(void) {
 355   1        static u32 systick_ms_bak = 0;
 356   1        if(millis() - systick_ms_bak < 50) {
 357   2          return;
 358   2        }
 359   1        systick_ms_bak = millis();
 360   1        psx_write_read(psx_buf);
 361   1      #if 0 
                sprintf(cmd_return, "0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x\r\n", 
C51 COMPILER V9.60.0.0   Z_MAIN                                                            07/09/2022 18:24:17 PAGE 7   

                (int)psx_buf[0], (int)psx_buf[1], (int)psx_buf[2], (int)psx_buf[3],
                (int)psx_buf[4], (int)psx_buf[5], (int)psx_buf[6], (int)psx_buf[7], (int)psx_buf[8]);
                uart1_send_str(cmd_return);
              #endif  
 367   1        
 368   1        return;
 369   1      }
 370          
 371          int __abs_int(int a) {
 372   1        if(a>0)return (a);
 373   1        return (-a);
 374   1      }
 375          
 376          void loop_ps2_joystick(void) {
 377   1        static int joystick_left_LR_bak=0, joystick_right_UD_bak=0, joystick_left_UD_bak;
 378   1        static int joystick_left_LR, joystick_right_UD, joystick_left_UD;
 379   1        
 380   1        if(psx_buf[1] != PS2_LED_RED)return;
 381   1        
 382   1        joystick_left_UD = (psx_buf[8]-127) * 8;
 383   1        joystick_left_LR = (psx_buf[7]-127) * 8;
 384   1        joystick_right_UD = (psx_buf[6]-127) * 8;
 385   1      
 386   1        if(__abs_int(joystick_left_LR - joystick_left_LR_bak) > 16 || __abs_int(joystick_left_UD - joystick_left_
             -UD_bak) > 16) {
 387   2      //    sprintf((char *)uart_receive_buf, "{#000P%04dT0100!#001P%04dT0000!#002P%04dT1000!#003P%04dT0000!#004P%
             -04dT0000!#005P%04dT0000!}", 
 388   2      //    1500+(psx_buf[7]-127) * 6,
 389   2      //    1500+(psx_buf[8]-127) * 4,1500-(psx_buf[8]-127) * 4,1500-(psx_buf[8]-127) * 4,1500+(psx_buf[8]-127) * 
             -4,1500+(psx_buf[8]-127) * 4);
 390   2          if(__abs_int(joystick_left_LR)<30)joystick_left_LR=0;
 391   2          sprintf((char *)uart_receive_buf, "#000P%04dT1000!#001P%04dT1000!#002P%04dT1000!#003P%04dT1000!#004P%04d
             -T1000!#005P%04dT1000!", 
 392   2          (int)(1500-joystick_left_LR*0.6),
 393   2          (int)(1500-joystick_left_UD*0.6),
 394   2          (int)(1500+joystick_left_UD*0.6),
 395   2          (int)(1500+joystick_left_UD*0.6),
 396   2          (int)(1500-joystick_left_UD*0.6),
 397   2          (int)(1500-joystick_left_UD*0.6));
 398   2          parse_action(uart_receive_buf);
 399   2          //uart1_send_str(uart_receive_buf);
 400   2          //zx_uart_send_str(cmd_return);
 401   2          
 402   2          joystick_left_LR_bak = joystick_left_LR;
 403   2          joystick_left_UD_bak = joystick_left_UD;
 404   2        }
 405   1        
 406   1        if(__abs_int(joystick_right_UD-joystick_right_UD_bak) > 16) {
 407   2          joystick_left_LR = (psx_buf[6]-127) * 4 - (psx_buf[5]-127) * 4;
 408   2          joystick_right_UD = (psx_buf[6]-127) * 4 + (psx_buf[5]-127) * 4;
 409   2          
 410   2          //sprintf((char *)uart_receive_buf, "{#000P%04dT0000!}", 1500+(joystick_left_LR-joystick_right_UD));
 411   2          //parse_action(uart_receive_buf);
 412   2          
 413   2          car_set(joystick_left_LR, joystick_right_UD);
 414   2          joystick_right_UD_bak = joystick_right_UD;
 415   2        }
 416   1      
 417   1      }
 418          
 419          
 420          
C51 COMPILER V9.60.0.0   Z_MAIN                                                            07/09/2022 18:24:17 PAGE 8   

 421          void loop_ps2_button(void) {
 422   1        static unsigned char psx_button_bak[2] = {0};
 423   1      
 424   1        if((psx_button_bak[0] == psx_buf[3])
 425   1        && (psx_button_bak[1] == psx_buf[4])) {     
 426   2        } else {
 427   2          parse_psx_buf(psx_buf+3, psx_buf[1]);
 428   2          //uart1_send_str("changed\r\n");
 429   2          psx_button_bak[0] = psx_buf[3];
 430   2          psx_button_bak[1] = psx_buf[4];
 431   2        }
 432   1        return;
 433   1      }
 434          
 435          //处理小车电机摇杆控制
 436          void loop_ps2_car(void) {
 437   1        static int car_left, car_right, car_left_bak, car_right_bak;
 438   1        
 439   1        if(psx_buf[1] != PS2_LED_RED)return;
 440   1        
 441   1        if(abs_int(127 - psx_buf[8]) < 5 )psx_buf[8] = 127;
 442   1        if(abs_int(127 - psx_buf[6]) < 5 )psx_buf[6] = 127;
 443   1        
 444   1        car_left = (127 - psx_buf[8]) * 8;
 445   1        car_right = (127 - psx_buf[6]) * 8;
 446   1        if (car_left > 1000) {
 447   2          car_left = 1000;
 448   2        } else if (car_left < -1000) {
 449   2          car_left = -1000;
 450   2        } else if (car_right > 1000) {
 451   2          car_right = 1000;
 452   2        } else if (car_right < -1000) {
 453   2          car_right = -1000;
 454   2        } 
 455   1        if(car_left != car_left_bak || car_right != car_right_bak) {
 456   2          //uart1_send_str((u8*)"ps2:");
 457   2          car_set(car_left, car_right);
 458   2          car_left_bak = car_left;
 459   2          car_right_bak = car_right;
 460   2        }
 461   1      }
 462          
 463          void parse_psx_buf(unsigned char *buf, unsigned char mode) {
 464   1        u8 i, pos = 0;
 465   1        static u16 bak=0xffff, temp, temp2;
 466   1        temp = (buf[0]<<8) + buf[1];
 467   1        
 468   1        if(bak != temp) {
 469   2          temp2 = temp;
 470   2          temp &= bak;
 471   2          for(i=0;i<16;i++) {
 472   3            if((1<<i) & temp) {
 473   4            } else {
 474   4              if((1<<i) & bak) {  //press
 475   5                                    
 476   5                memset(uart_receive_buf, 0, sizeof(uart_receive_buf));          
 477   5                if(mode == PS2_LED_RED) {
 478   6                  memcpy((char *)uart_receive_buf, (char *)pre_cmd_set_red[i], strlen(pre_cmd_set_red[i]));
 479   6                } else if(mode == PS2_LED_GRN) {
 480   6                  memcpy((char *)uart_receive_buf, (char *)pre_cmd_set_grn[i], strlen(pre_cmd_set_grn[i]));
 481   6                } else continue;
 482   5                
C51 COMPILER V9.60.0.0   Z_MAIN                                                            07/09/2022 18:24:17 PAGE 9   

 483   5                pos = str_contain_str(uart_receive_buf, "^");
 484   5                if(pos) uart_receive_buf[pos-1] = '\0';
 485   5                if(str_contain_str(uart_receive_buf, "$")) {
 486   6                  //uart1_close();
 487   6                  //uart1_get_ok = 1;
 488   6                  //uart1_mode = 1;
 489   6                  strcpy(cmd_return, uart_receive_buf+11);
 490   6                  strcpy(uart_receive_buf, cmd_return);
 491   6                  parse_cmd(uart_receive_buf);
 492   6                } else if(str_contain_str(uart_receive_buf, "#")) {
 493   6                  //uart1_close();
 494   6                  //uart1_get_ok = 1;
 495   6                  //uart1_mode = 2;
 496   6                  strcpy(cmd_return, uart_receive_buf+11);
 497   6                  strcpy(uart_receive_buf, cmd_return);
 498   6                  parse_action(uart_receive_buf);
 499   6                }
 500   5                
 501   5                //uart1_send_str(uart_receive_buf);
 502   5                //zx_uart_send_str(uart_receive_buf);
 503   5                
 504   5                bak = 0xffff;
 505   5              } else {//release
 506   5                          
 507   5                memset(uart_receive_buf, 0, sizeof(uart_receive_buf));          
 508   5                if(mode == PS2_LED_RED) {
 509   6                  memcpy((char *)uart_receive_buf, (char *)pre_cmd_set_red[i], strlen(pre_cmd_set_red[i]));
 510   6                } else if(mode == PS2_LED_GRN) {
 511   6                  memcpy((char *)uart_receive_buf, (char *)pre_cmd_set_grn[i], strlen(pre_cmd_set_grn[i]));
 512   6                } else continue;  
 513   5                
 514   5                pos = str_contain_str(uart_receive_buf, "^");
 515   5                if(pos) {
 516   6                  if(str_contain_str(uart_receive_buf+pos, "$")) {
 517   7                    //uart1_close();
 518   7                    //uart1_get_ok = 1;
 519   7                    //uart1_mode = 1;
 520   7                    strcpy(cmd_return, uart_receive_buf+pos);
 521   7                    cmd_return[strlen(cmd_return) - 1] = '\0';
 522   7                    strcpy(uart_receive_buf, cmd_return);
 523   7                    parse_cmd(uart_receive_buf);
 524   7                  } else if(str_contain_str(uart_receive_buf+pos, "#")) {
 525   7                    //uart1_close();
 526   7                    //uart1_get_ok = 1;
 527   7                    //uart1_mode = 2;
 528   7                    strcpy(cmd_return, uart_receive_buf+pos);
 529   7                    cmd_return[strlen(cmd_return) - 1] = '\0';
 530   7                    strcpy(uart_receive_buf, cmd_return);
 531   7                    parse_action(uart_receive_buf);
 532   7                  }
 533   6                  //uart1_send_str(uart_receive_buf);
 534   6                  //zx_uart_send_str(uart_receive_buf);
 535   6                } 
 536   5              }
 537   4              //测试执行指令
 538   4              //uart1_send_str(uart_receive_buf);
 539   4      
 540   4            }
 541   3          }
 542   2          bak = temp2;
 543   2          beep_on();mdelay(50);beep_off();
 544   2        } 
C51 COMPILER V9.60.0.0   Z_MAIN                                                            07/09/2022 18:24:17 PAGE 10  

 545   1        return;
 546   1      }
 547          
 548          void handle_uart(void) {
 549   1      
 550   1      
 551   1        return;
 552   1      }
 553          
 554          /*
 555            $DST!
 556            $DST:x!
 557            $RST!
 558            $CGP:%d-%d!
 559            $DEG:%d-%d!
 560            $DGS:x!
 561            $DGT:%d-%d,%d!
 562            $DCR:%d,%d!
 563            $DWA!
 564            $DWD!
 565            $DJR!
 566            $GETA!
 567          */
 568          
 569          void parse_cmd(u8 *cmd) {
 570   1        static u8 djrFlag=0;
 571   1        u16 pos, i, index;
 572   1        int int1, int2, int3, int4;
 573   1        
 574   1        uart1_send_str(cmd);
 575   1        
 576   1        if(pos = str_contain_str(cmd, "$DST!"), pos) {
 577   2          group_do_ok  = 1;
 578   2          for(i=0;i<DJ_NUM;i++) {
 579   3            duoji_doing[i].inc = 0; 
 580   3            duoji_doing[i].aim = duoji_doing[i].cur;
 581   3          }
 582   2          zx_uart_send_str("#255PDST!");
 583   2          car_set(0, 0);
 584   2          AI_mode = 255;
 585   2        } else if(pos = str_contain_str(cmd, "$DST:"), pos) {
 586   2          if(sscanf(cmd, "$DST:%d!", &index)) {
 587   3            duoji_doing[index].inc = 0; 
 588   3            duoji_doing[index].aim = duoji_doing[index].cur;
 589   3            sprintf(cmd_return, "#%03dPDST!", (int)index);
 590   3            zx_uart_send_str(cmd_return);
 591   3          }
 592   2          
 593   2          
 594   2        } else if(pos = str_contain_str(cmd, "$RST!"), pos) {   
 595   2          soft_reset();
 596   2        } else if(pos = str_contain_str(cmd, "$PTG:"), pos) {   
 597   2          if(sscanf(cmd, "$PTG:%d-%d!", &int1, &int2)) {
 598   3            print_group(int1, int2);
 599   3          }
 600   2        } else if(pos = str_contain_str(cmd, "$DEG:"), pos) {   
 601   2          if(sscanf(cmd, "$DEG:%d-%d!", &int1, &int2)) {
 602   3            erase_sector(int1, int2);
 603   3          }
 604   2        } else if(pos = str_contain_str(cmd, "$DGS:"), pos) {   
 605   2          if(sscanf(cmd, "$DGS:%d!", &int1)) {
 606   3            do_group_once(int1);
C51 COMPILER V9.60.0.0   Z_MAIN                                                            07/09/2022 18:24:17 PAGE 11  

 607   3            group_do_ok = 1;
 608   3          }
 609   2        } else if(pos = str_contain_str(cmd, "$DGT:"), pos) {   
 610   2          if(sscanf((char *)cmd, "$DGT:%d-%d,%d!", &group_num_start, &group_num_end, &group_num_times)) {
 611   3            //uart1_send_str("111111");     
 612   3            if(group_num_start != group_num_end) {
 613   4              do_start_index = group_num_start;
 614   4              do_time = group_num_times;
 615   4              group_do_ok = 0;
 616   4              //uart1_send_str("22222");
 617   4            } else {
 618   4              group_do_ok = 1;
 619   4              do_group_once(group_num_start);
 620   4              //uart1_send_str("33333");
 621   4            }
 622   3          }
 623   2        } else if(pos = str_contain_str(cmd, "$DCR:"), pos) {   
 624   2          if(sscanf(cmd, "$DCR:%d,%d!", &int1, &int2)) {
 625   3            car_set(int1, int2);
 626   3          }
 627   2        } else if(pos = str_contain_str(cmd, "$DJR!"), pos) { 
 628   2          zx_uart_send_str("#255P1500T2000!");    
 629   2          //将偏差带入初始值
 630   2          for(i=0;i<DJ_NUM;i++) {
 631   3            duoji_doing[i].aim = 1500+eeprom_info.dj_bias_pwm[i];
 632   3            duoji_doing[i].inc = (duoji_doing[i].aim -  duoji_doing[i].cur) / (duoji_doing[i].time/20.000);
 633   3          }
 634   2        } else if(pos = str_contain_str(cmd, "$JXB_SWITCH!"), pos) {  
 635   2          group_do_ok = 1;
 636   2          zx_uart_send_str("#255P1500T2000!");    
 637   2          for(i=0;i<DJ_NUM;i++) {
 638   3            duoji_doing[i].aim  = 1500;
 639   3            duoji_doing[i].time = 2000;
 640   3            duoji_doing[i].inc = (duoji_doing[i].aim -  duoji_doing[i].cur) / (duoji_doing[i].time/20.000);
 641   3          }
 642   2          
 643   2          if(djrFlag) {
 644   3            do_group_once(1);
 645   3          } else {
 646   3            do_group_once(2);
 647   3          }
 648   2          djrFlag = !djrFlag;
 649   2        } else if(pos = str_contain_str(cmd, "$GETA!"), pos) {    
 650   2          uart1_send_str("AAA");
 651   2        } else if(pos = str_contain_str(cmd, "$GETS!"), pos) {    
 652   2          if(group_do_ok == 0) {
 653   3            uart1_send_str("group_do_ok=0");
 654   3          } else {
 655   3            uart1_send_str("group_do_ok=1");
 656   3          }
 657   2        } else if(pos = str_contain_str(cmd, "$GETINC!"), pos) {    
 658   2          for(i=0;i<8;i++) {
 659   3            sprintf(cmd_return, "inc%d = %f \r\n", (int)i, duoji_doing[i].inc);
 660   3            uart1_send_str(cmd_return);
 661   3          }
 662   2        } else if(pos = str_contain_str(cmd, "$DRS!"), pos) { 
 663   2          uart1_send_str("\r\n51MCU-IAP15W4K61S4 Ver:");
 664   2          uart1_send_str(VERSION);
 665   2        } else if(pos = str_contain_str(cmd, (u8 *)"$SMODE"), pos) {    
 666   2          if(sscanf((char *)cmd, "$SMODE%d!", &int1)) {
 667   3            if(int1 < 10) {
 668   4              AI_mode = int1;
C51 COMPILER V9.60.0.0   Z_MAIN                                                            07/09/2022 18:24:17 PAGE 12  

 669   4              beep_on_times(1, 100);
 670   4              car_set(0,0);
 671   4            }
 672   3          }
 673   2        } else if(pos = str_contain_str(cmd, (u8 *)"$SMART_STOP!"), pos) {    
 674   2          AI_mode = 255;
 675   2          beep_on_times(1, 100);
 676   2          parse_action((u8 *)"#255PDST!");
 677   2          uart1_send_str((u8 *)"@OK!");
 678   2        }  else if(pos = str_contain_str(cmd, (u8 *)"$KMS:"), pos) {    
 679   2          if(sscanf((char *)cmd, "$KMS:%d,%d,%d,%d!", &int1, &int2, &int3, &int4)) {
 680   3            uart1_send_str((u8 *)"Try to find best pos:\r\n");
 681   3            if(kinematics_move(0, int2, int3, int4)) {
 682   4              beep_on();mdelay(50);beep_off();mdelay(50);
 683   4            } else {
 684   4              beep_on();mdelay(50);beep_off();mdelay(50);
 685   4              beep_on();mdelay(50);beep_off();mdelay(50);
 686   4              uart1_send_str((u8 *)"Can't find best pos!!!");
 687   4            }         
 688   3          }
 689   2        }
 690   1      }
 691          
 692          
 693          
 694          void action_save(u8 *str) {
 695   1        int action_index = 0;
 696   1        //预存命令处理
 697   1        
 698   1        if(str[1] == '$' && str[2] == '!') {
 699   2          eeprom_info.pre_cmd[PRE_CMD_SIZE] = 0;
 700   2          rewrite_eeprom();
 701   2          uart1_send_str((u8 *)"@CLEAR PRE_CMD OK!");
 702   2          return;
 703   2        } else if(str[1] == '$') {
 704   2          if(sscanf((char *)str, "<$DGT:%d-%d,%d!>", &group_num_start, &group_num_end, &group_num_times)) {
 705   3            if(group_num_start == group_num_end) {
 706   4              w25x_read(eeprom_info.pre_cmd, group_num_start*ACTION_SIZE, ACTION_SIZE); 
 707   4            } else {
 708   4              memset(eeprom_info.pre_cmd, 0, sizeof(eeprom_info.pre_cmd));
 709   4              strcpy((char *)eeprom_info.pre_cmd, (char *)str+1);
 710   4              eeprom_info.pre_cmd[strlen((char *)str) - 2] = '\0';
 711   4            }
 712   3            eeprom_info.pre_cmd[PRE_CMD_SIZE] = FLAG_VERIFY;
 713   3            rewrite_eeprom();
 714   3            //uart1_send_str(eeprom_info.pre_cmd);
 715   3            uart1_send_str((u8 *)"@SET PRE_CMD OK!");
 716   3          }
 717   2          return;
 718   2        }
 719   1        
 720   1        action_index = get_action_index(str);
 721   1        //<G0001#001...>
 722   1        if((action_index == -1) || str[6] != '#'){
 723   2        //if( action_index == -1 ){
 724   2          uart1_send_str("E");
 725   2          return;
 726   2        }
 727   1        //save_action_index_bak++;
 728   1        if(action_index*ACTION_SIZE % W25Q64_SECTOR_SIZE == 0)w25x_erase_sector(action_index*ACTION_SIZE/W25Q64_S
             -ECTOR_SIZE);
 729   1        replace_char(str, '<', '{');
C51 COMPILER V9.60.0.0   Z_MAIN                                                            07/09/2022 18:24:17 PAGE 13  

 730   1        replace_char(str, '>', '}');
 731   1        w25x_write(str, action_index*ACTION_SIZE, strlen(str) + 1);
 732   1        //uart1_send_str(str);
 733   1        uart1_send_str("A");
 734   1        return; 
 735   1      }
 736          
 737          int get_action_index(u8 *str) {
 738   1        int index = 0;
 739   1        //uart_send_str(str);
 740   1        while(*str) {
 741   2          if(*str == 'G') {
 742   3            str++;
 743   3            while((*str != '#') && (*str != '$')) {
 744   4              index = index*10 + *str-'0';
 745   4              str++;  
 746   4            }
 747   3            return index;
 748   3          } else {
 749   3            str++;
 750   3          }
 751   2        }
 752   1        return -1;
 753   1      }
 754          
 755          void print_group(int start, int end) {
 756   1        if(start > end) {
 757   2          int_exchange(&start, &end);
 758   2        }
 759   1        for(;start<=end;start++) {
 760   2          memset(uart_receive_buf, 0, sizeof(uart_receive_buf));
 761   2          w25x_read(uart_receive_buf, start*ACTION_SIZE, ACTION_SIZE);
 762   2          uart1_send_str(uart_receive_buf);
 763   2          uart1_send_str("\r\n");
 764   2        }
 765   1      }
 766          
 767          
 768          void int_exchange(int *int1, int *int2) {
 769   1        int int_temp;
 770   1        int_temp = *int1;
 771   1        *int1 = *int2;
 772   1        *int2 = int_temp;
 773   1      }
 774          
 775          void erase_sector(int start, int end) {
 776   1        if(start > end) {
 777   2          int_exchange(&start, &end);
 778   2        }
 779   1        if(end >= 127)end = 127;
 780   1        for(;start<=end;start++) {
 781   2          SpiFlashEraseSector(start);
 782   2          sprintf(cmd_return, "@Erase %d OK!", start);
 783   2          uart1_send_str(cmd_return);
 784   2        }
 785   1        save_action_index_bak = 0;
 786   1      }
 787          
 788          //获取最大时间
 789          int getMaxTime(u8 *str) {
 790   1         int i = 0, max_time = 0, tmp_time = 0;
 791   1         while(str[i]) {
C51 COMPILER V9.60.0.0   Z_MAIN                                                            07/09/2022 18:24:17 PAGE 14  

 792   2            if(str[i] == 'T') {
 793   3                tmp_time = (str[i+1]-'0')*1000 + (str[i+2]-'0')*100 + (str[i+3]-'0')*10 + (str[i+4]-'0');
 794   3                if(tmp_time>max_time)max_time = tmp_time;
 795   3                i = i+4;
 796   3                continue;
 797   3            }
 798   2            i++;
 799   2         }
 800   1         return max_time;
 801   1      }
 802          
 803          void do_group_once(int group_num) {
 804   1        memset(uart_receive_buf, 0, sizeof(uart_receive_buf));
 805   1        //从存储芯片中读取第group_num个动作组
 806   1        w25x_read(uart_receive_buf, group_num*ACTION_SIZE, ACTION_SIZE);
 807   1        //获取最大的组时间
 808   1        action_time = getMaxTime(uart_receive_buf); 
 809   1        //把读取出来的动作组传递到parse_action执行
 810   1        parse_action(uart_receive_buf);
 811   1        sprintf((char *)cmd_return, "@DoGroup %d OK!\r\n", group_num);
 812   1        //uart1_send_str(cmd_return);
 813   1      }
 814          
 815          void loop_action(void) {
 816   1        static u32 systick_ms_bak = 0;
 817   1        if(group_do_ok == 0) {
 818   2          if(millis() - systick_ms_bak > action_time) {
 819   3            systick_ms_bak =  millis();
 820   3            if(group_num_times != 0 && do_time == 0) {
 821   4              group_do_ok = 1;
 822   4              uart1_send_str((u8 *)"@GroupDone!");
 823   4              return;
 824   4            }
 825   3            //调用do_start_index个动作
 826   3            do_group_once(do_start_index);
 827   3            
 828   3            if(group_num_start<group_num_end) {
 829   4              if(do_start_index == group_num_end) {
 830   5                do_start_index = group_num_start;
 831   5                if(group_num_times != 0) {
 832   6                  do_time--;
 833   6                }
 834   5                return;
 835   5              }
 836   4              do_start_index++;
 837   4            } else {
 838   4              if(do_start_index == group_num_end) {
 839   5                do_start_index = group_num_start;
 840   5                if(group_num_times != 0) {
 841   6                  do_time--;
 842   6                }
 843   5                return;
 844   5              }
 845   4              do_start_index--;
 846   4            }
 847   3          }
 848   2        } else {
 849   2            action_time = 10;
 850   2        }
 851   1      }
 852          
 853          u8 check_dj_state(void) {
C51 COMPILER V9.60.0.0   Z_MAIN                                                            07/09/2022 18:24:17 PAGE 15  

 854   1        int i;
 855   1        float inc = 0;
 856   1        for(i=0;i<DJ_NUM;i++) {
 857   2          inc += duoji_doing[i].inc;
 858   2          if(inc)return 1;
 859   2        }
 860   1        return 0;
 861   1      }
 862          
 863          void parse_action(u8 *uart_receive_buf) {
 864   1        u16 index,  time, i = 0, j, step = 0;
 865   1        int bias;
 866   1        float pwm;
 867   1        float aim_temp;
 868   1        //zx_uart_send_str(uart_receive_buf);
 869   1        if(uart_receive_buf[0] == '#' && uart_receive_buf[4] == 'P' && uart_receive_buf[5] == 'S' && uart_receive
             -_buf[6] == 'C' && uart_receive_buf[7] == 'K' && uart_receive_buf[12] == '!') {
 870   2          index = (uart_receive_buf[1] - '0')*100 + (uart_receive_buf[2] - '0')*10 + (uart_receive_buf[3] - '0');
 871   2          bias = (uart_receive_buf[9] - '0')*100 + (uart_receive_buf[10] - '0')*10 + (uart_receive_buf[11] - '0');
 872   2          if((bias >= -500) && (bias <= 500) && (index < DJ_NUM)) {
 873   3            if(uart_receive_buf[8] == '+') {
 874   4            } else if(uart_receive_buf[8] == '-') {
 875   4              bias = -bias;
 876   4            }
 877   3            aim_temp = duoji_doing[index].cur - eeprom_info.dj_bias_pwm[index] + bias;
 878   3            eeprom_info.dj_bias_pwm[index] = bias;      
 879   3            if(aim_temp > 2497){
 880   4              aim_temp = 2497;
 881   4            } else if(aim_temp < 500) {
 882   4              aim_temp = 500;
 883   4            }
 884   3            
 885   3            duoji_doing[index].aim = aim_temp;
 886   3            duoji_doing[index].inc = (duoji_doing[index].aim - duoji_doing[index].cur)/5;
 887   3            bias_systick_ms_bak = millis();
 888   3            needSaveFlag = 1;
 889   3          }
 890   2          return;
 891   2        } else if(uart_receive_buf[0] == '#' && uart_receive_buf[4] == 'P' && uart_receive_buf[5] == 'D' && uart_
             -receive_buf[6] == 'S' && uart_receive_buf[7] == 'T' && uart_receive_buf[8] == '!') {
 892   2          index = (uart_receive_buf[1] - '0')*100 + (uart_receive_buf[2] - '0')*10 + (uart_receive_buf[3] - '0'); 
             -  
 893   2          if(index < DJ_NUM) {
 894   3            duoji_doing[index].inc = 0; 
 895   3            duoji_doing[index].aim = duoji_doing[index].cur;
 896   3          }
 897   2          return;
 898   2        }
 899   1        
 900   1        step = 1;
 901   1        while(uart_receive_buf[i]) {
 902   2          if(uart_receive_buf[i] == '#' && step == 1) {
 903   3            j = i;
 904   3            index = 0;i++;
 905   3            while(uart_receive_buf[i] && uart_receive_buf[i] != 'P') {
 906   4              index = index*10 + uart_receive_buf[i]-'0';i++;
 907   4            }
 908   3            if(i-j-1 != 3) {
 909   4              step = 1;
 910   4            } else {
 911   4              step = 2;
 912   4            }
C51 COMPILER V9.60.0.0   Z_MAIN                                                            07/09/2022 18:24:17 PAGE 16  

 913   3          } else if(uart_receive_buf[i] == 'P' && step == 2) {
 914   3            j = i;
 915   3            pwm = 0;i++;
 916   3            while(uart_receive_buf[i] && uart_receive_buf[i] != 'T') {
 917   4              pwm = pwm*10 + uart_receive_buf[i]-'0';i++;
 918   4            }
 919   3            if(i-j-1 != 4) {
 920   4              step = 1;
 921   4            } else {
 922   4              step = 3;
 923   4            }
 924   3          } else if(uart_receive_buf[i] == 'T' && step == 3) {
 925   3            j = i;
 926   3            time = 0;i++;
 927   3            while(uart_receive_buf[i] && uart_receive_buf[i] != '!') {
 928   4              time = time*10 + uart_receive_buf[i]-'0';i++;
 929   4            }
 930   3            
 931   3            //同步的时候防止数据太快不稳定
 932   3            if(time<500) {
 933   4              time = time+300;
 934   4            }
 935   3            
 936   3            step = 1;
 937   3            if(i-j-1 != 4) {
 938   4            } else {
 939   4              if(index < DJ_NUM && (pwm<=2500)&& (pwm>=500) && (time<=10000)) {
 940   5                pwm += eeprom_info.dj_bias_pwm[index];
 941   5                
 942   5                if(pwm>2497)pwm=2497;
 943   5                if(pwm<500)pwm=500;
 944   5                
 945   5                if(time < 20) {
 946   6                  duoji_doing[index].aim = pwm;
 947   6                  duoji_doing[index].cur = pwm;
 948   6                  duoji_doing[index].inc = 0;
 949   6                } else {
 950   6                  duoji_doing[index].aim = pwm;
 951   6                  duoji_doing[index].time = time;
 952   6                  duoji_doing[index].inc = (duoji_doing[index].aim -  duoji_doing[index].cur) / (duoji_doing[index].ti
             -me/20.000);
 953   6                }
 954   5      
 955   5                //sprintf(cmd_return, "#%03dP%04dT%04d! %f \r\n", index, pwm, time, duoji_doing[index].inc);
 956   5                //uart1_send_str(cmd_return);
 957   5              } 
 958   4              
 959   4              if(index == 255) {
 960   5                for(index=0;index<DJ_NUM;index++) {
 961   6                  pwm =1500 + eeprom_info.dj_bias_pwm[index];
 962   6                  duoji_doing[index].aim = pwm;
 963   6                  duoji_doing[index].time = time;
 964   6                  duoji_doing[index].inc = (duoji_doing[index].aim -  duoji_doing[index].cur) / (duoji_doing[index].ti
             -me/20.000);
 965   6                }
 966   5              }
 967   4            }
 968   3          } else {
 969   3            i++;
 970   3          }
 971   2        } 
 972   1      }
C51 COMPILER V9.60.0.0   Z_MAIN                                                            07/09/2022 18:24:17 PAGE 17  

 973          
 974          void replace_char(u8*str, u8 ch1, u8 ch2) {
 975   1        while(*str) {
 976   2          if(*str == ch1) {
 977   3            *str = ch2;
 978   3          } 
 979   2          str++;
 980   2        }
 981   1        return;
 982   1      }
 983          
 984          //把eeprom_info写入到W25Q64_INFO_ADDR_SAVE_STR位置
 985          void rewrite_eeprom(void) {
 986   1        w25x_erase_sector(W25Q64_INFO_ADDR_SAVE_STR/W25Q64_SECTOR_SIZE);
 987   1        w25x_write((u8 *)(&eeprom_info), W25Q64_INFO_ADDR_SAVE_STR, sizeof(eeprom_info_t));
 988   1      }
 989          
 990          void loop_bt_once(void) {
 991   1        static u8 first_change = 1, step = 0;
 992   1        static u32 systick_ms_bak = 0;
 993   1        if(first_change) {
 994   2          if((millis() - systick_ms_bak > 500) && (step == 0)) {
 995   3            systick_ms_bak = millis();
 996   3            uart4_init(9600);
 997   3            uart4_open();
 998   3            uart4_send_str((u8 *)"AT+BAUD8\r\n");
 999   3            step++;
1000   3          } else if((millis() - systick_ms_bak > 500) && (step == 1)){
1001   3            systick_ms_bak = millis();    
1002   3            uart4_init(115200);
1003   3            step++;
1004   3          }  else if((millis() - systick_ms_bak > 500) && (step == 2)){
1005   3            systick_ms_bak = millis();    
1006   3            uart4_send_str((u8 *)"AT+SPPNAMEZL-51-BT2.0\r\n");
1007   3            step++;
1008   3          } else if((millis() - systick_ms_bak > 500) && (step == 3)){
1009   3            systick_ms_bak = millis();
1010   3            uart4_send_str((u8 *)"AT+LENAMEZL-51-BT4.0\r\n");
1011   3            step++;
1012   3          } else if((millis() - systick_ms_bak > 500) && (step == 4)){
1013   3            systick_ms_bak = millis();
1014   3            uart4_send_str((u8 *)"AT+NAMEZL-51-BT2.0\r\n");
1015   3            step++;
1016   3            first_change = 0;
1017   3          } 
1018   2        }
1019   1      }
1020          
1021          void soft_reset(void) {
1022   1        IAP_CONTR = 0X60;
1023   1      }
1024          
1025          void car_set(int car_left, int car_right) {
1026   1        //总线马达设置  
1027   1        sprintf((char *)cmd_return, "{#006P%04dT0000!#007P%04dT0000!}", (int)(1500+car_left), (int)(1500-car_righ
             -t));
1028   1        zx_uart_send_str(cmd_return);     
1029   1        return;
1030   1      }
1031          
1032          
1033          void set_servo(int index, int pwm, int time) {
C51 COMPILER V9.60.0.0   Z_MAIN                                                            07/09/2022 18:24:17 PAGE 18  

1034   1        duoji_doing[index].aim = pwm;
1035   1        duoji_doing[index].time = time;
1036   1        duoji_doing[index].inc = (duoji_doing[index].aim -  duoji_doing[index].cur) / (duoji_doing[index].time/20
             -.000);
1037   1        sprintf((char *)cmd_return, "#%03dP%04dT%04d!(%.1f)\r\n", index, pwm, time, kinematics.servo_angle[index]
             -);
1038   1        uart1_send_str(cmd_return); 
1039   1      }
1040          
1041          
1042          
1043          int kinematics_move(float x, float y, float z, int time) {
1044   1        int i,j, min = 0, flag = 0;
1045   1        
1046   1        if(y < 0)return 0;
1047   1        //寻找最佳角度
1048   1        flag = 0;
1049   1        for(i=0;i>=-135;i--) {
1050   2          if(0 == kinematics_analysis(x,y,z,i,&kinematics)){
1051   3            min = i;
1052   3            flag = 1;
1053   3            break;
1054   3            //if(i<min)min = i;
1055   3            //flag = 1;
1056   3          }
1057   2        }
1058   1        
1059   1        //用3号舵机与水平最大的夹角作为最佳值
1060   1        if(flag) {
1061   2          kinematics_analysis(x,y,z,min,&kinematics);
1062   2          for(j=1;j<4;j++) {
1063   3            set_servo(j, kinematics.servo_pwm[j], time);
1064   3          }
1065   2          return 1;
1066   2        }
1067   1        
1068   1        return 0;
1069   1      }
1070          
1071          
1072          
1073          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  11243    ----
   CONSTANT SIZE    =   1907    ----
   XDATA SIZE       =    170     115
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
